import inspect
import json
from typing import Any, Dict, List
from fastapi.routing import APIRoute
from fastapi import FastAPI
from ai_engine import llm_generate_summary


def extract_routes(app: FastAPI) -> List[Dict[str, Any]]:
    """Extract metadata for all routes in the FastAPI app."""
    routes = []

    for route in app.routes:
        if isinstance(route, APIRoute):
            routes.append({
                "path": route.path,
                "methods": sorted(list(route.methods)),
                "name": route.name,
                "endpoint": route.endpoint.__name__,
                "doc": inspect.getdoc(route.endpoint) or "",
            })
    return routes


def generate_markdown(routes: List[Dict[str, Any]]) -> str:
    """Generate Markdown API documentation."""
    lines = ["# API Documentation (Generated by AutoDoc)", ""]

    for r in routes:
        summary = llm_generate_summary(r["doc"]) if r["doc"] else ""

        lines.append(f"## {r['name']}")
        lines.append(f"**Path:** `{r['path']}`")
        lines.append(f"**Methods:** {', '.join(r['methods'])}")
        lines.append(f"**AI Summary:** {summary}")
        lines.append(f"**Original Docstring:** {r['doc']}")
        lines.append("")

    return "\n".join(lines)


def generate_openapi(routes: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Generate a minimal OpenAPI specification."""
    openapi = {
        "openapi": "3.1.0",
        "paths": {}
    }

    for r in routes:
        entry = {}
        for m in r["methods"]:
            entry[m.lower()] = {
                "summary": r["doc"][:200] or r["name"],
                "operationId": r["endpoint"]
            }
        openapi["paths"][r["path"]] = entry

    return openapi


def ai_generate_tests(route: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate human-like test cases."""
    path = route["path"]
    methods = route["methods"]
    tests = []

    # Positive GET
    if "GET" in methods:
        tests.append({
            "test_name": f"Test successful GET {path}",
            "method": "GET",
            "input": None,
            "expected_status": 200,
            "expected_output": "JSON object with expected fields"
        })

    # Positive POST
    if "POST" in methods:
        tests.append({
            "test_name": f"Test successful POST {path}",
            "method": "POST",
            "input": {"name": "Alice", "age": 25},
            "expected_status": 200,
            "expected_output": "received: payload echoed back"
        })

        tests.append({
            "test_name": f"Test POST {path} with invalid payload",
            "method": "POST",
            "input": "INVALID_JSON",
            "expected_status": 422,
            "expected_output": "Unprocessable Entity"
        })

    # Negative: unsupported method
    for m in ["GET", "POST", "PUT", "DELETE", "PATCH"]:
        if m not in methods:
            tests.append({
                "test_name": f"Test {path} rejects {m}",
                "method": m,
                "expected_status": 405,
                "expected_output": "Method Not Allowed"
            })
            break

    return tests


def generate_testcases(routes: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Aggregate test cases for all endpoints."""
    all_tests = []

    for r in routes:
        all_tests.append({
            "endpoint": r["path"],
            "methods": r["methods"],
            "ai_suggested_tests": ai_generate_tests(r)
        })

    return {"tests": all_tests}
